(function (global){
var ym = { modules: global.ymaps.modules };

(function (modules){
var project = { DEBUG: false };
if (typeof modules == 'undefined' && typeof require == 'function') {
    var modules = require('ym');
}

modules.define('util.providePackage', ['system.mergeImports'], function (provide, mergeImports) {
    provide(function (srcPackage, packageArgs) {
        var packageProvide = packageArgs[0],
            packageModules = Array.prototype.slice.call(packageArgs, 1),
            ns = mergeImports.joinImports(srcPackage.name, {}, srcPackage.deps, packageModules);

        packageProvide(ns);
    });
});
})(ym.modules);

ym.modules.define('app-config', [
], function (provide) {
  provide({
    map: {
      container: 'ymap',
      state: {
        center: [55.751574, 37.573856],
        zoom: 9,
        controls: ['zoomControl', 'geolocationControl', 'typeSelector', 'fullscreenControl']
      },
      options: {
        suppressMapOpenBlock: true
      }
    },
    stat: {
      url: '/api/v1/stat/',
      method: 'GET'
    },
    geocodeProvider: {
      url: '/api/v1/geocode/',
      method: 'POST'
    },
    form: {
      CSV: {
        request: {
          label: 'Адреса или координаты через разделитель',
          placeholder: 'Москва~Санкт-Петербург~Новосибирск~Екатеринбург~Нижний Новгород~Казань~Челябинск~Омск~Самара~Ростов-на-Дону~Уфа~Красноярск~Пермь~Воронеж~Волгоград'
        },
        delim: {
          placeholder: '~'
        }
      },
      GeoJSON: {
        request: {
          label: 'Координаты в формате GeoJSON',
          placeholder: '{"type":"FeatureCollection","features":[\n\t{"type":"Feature","geometry":{"type":"Point","coordinates":[55.75396,37.620393]}},\n\t{"type":"Feature","geometry":{"type":"Point","coordinates":[59.939095,30.315868]}},\n\t{"type":"Feature","geometry":{"type":"Point","coordinates":[55.030199,82.92043]}}\n]}',
        }
      }
    }
  });
});

ym.modules.define('app', [
  'util.defineClass',
  'util.extend',
  'objects-map-view',
  'form-dom-view',
  'geocode-model',
  'csv-request-data-view',
  'geojson-request-data-view',
  'proxy-geocode-provider',
  'stat-model',
  'stat-dom-view',
  'preloader-dom-view',
  'error-dom-view',
  'app-config'
], function (
  provide,
  defineClass,
  extend,
  ObjectsMapView,
  FormDomView,
  GeocodeModel,
  CSVRequestDataView,
  GeoJSONRequestDataView,
  ProxyGeocodeProvider,
  StatModel,
  StatDomView,
  PreloaderDomView,
  ErrorDomView,
  config
) {
  var App = defineClass(function () {
    this._mapView = new ObjectsMapView(config.map);
    this._formView = new FormDomView(config.ui);
    this._geocodeModel = new GeocodeModel({
      provider: new ProxyGeocodeProvider(config.geocodeProvider)
    });
    this._statModel = new StatModel();
    this._statView = new StatDomView();
    this._preloaderView = new PreloaderDomView();
    this._errorView = new ErrorDomView();
    this._setupListeners();
    this._statModel.load();
  }, {
    _setupListeners: function () {
      this._formView.events
        .add('formsubmit', this._onFormSubmit, this)
        .add('formreset', this._onFormReset, this);
      this._geocodeModel.events
        .add('requestsend', this._onGeocodeRequestSend, this)
        .add('requestfail', this._onGeocodeRequestFail, this)
        .add('requestsuccess', this._onGeocodeRequestSuccess, this);
      this._statModel.events.add('requestsuccess', this._onStatRequestSuccess, this);
    },
    _clearListeners: function () {
    },
    _onFormSubmit: function (e) {
      this._geocodeModel.data.set('request', this._formView.getRequestData());
    },
    _onFormReset: function (e) {
      this._mapView.clear();
    },
    _onStatRequestSuccess: function (e) {
      this._statView.render(this._statModel.data.getAll());
    },
    _onGeocodeRequestSend: function (e) {
      this._preloaderView.render();
    },
    _onGeocodeRequestSuccess: function () {
      var response = this._geocodeModel.data.get('response.result');

      this._preloaderView.clear();
      this._mapView
        .clear()
        .render(response);
      this._formView
        .clear()
        .render(response);
      this._statModel.load();
    },
    _onGeocodeRequestFail: function (e) {
      this._preloaderView.clear();
      this._errorView.render(this._geocodeModel.data.get('error'));
    }
  });

  provide(App);
});

ym.modules.define('proxy-geocode-provider', [
  'util.defineClass',
  'util.extend',
  'vow',
  'component.xhr'
], function (provide, defineClass, extend, vow, XHR) {

  var config = { timeout: 10 };
  var requests = [];
  var defer = vow.defer();
  var timer;

  function cleanUp() {
    timer = null;
    requests.length = 0;
    defer = vow.defer();
  }

  function sendRequest() {
    var xhr = new XHR(config.url, {
      method: config.method,
      data: requests
    }).then(
      defer.resolve,
      defer.reject,
      defer.notify,
      defer
    );
    cleanUp();
  }

  function normalizeOptions(options) {
    if(options == null || Object.keys(options) == 'provider') {
      return;
    }

    return {
      boundedBy: options.boundedBy,
      strictBounds: options.strictBounds
    };
  }

  var ProxyGeocodeProvider = defineClass(function (options) {
    extend(config, options);
  }, {
    geocode: function (request, options) {
      requests.push({ request: request, options: normalizeOptions(options) });
      clearTimeout(timer);
      timer = setTimeout(sendRequest, config.timeout);

      return defer.promise();
    }
  });

  provide(ProxyGeocodeProvider);
});

ym.modules.define('geocode-model', [
  'util.defineClass',
  'util.extend',
  'event.Manager',
  'data.Manager',
  'option.Manager',
  'Monitor',
  'geocode',
  'proxy-geocode-provider'
], function (provide, defineClass, extend, EventManager, DataManager, OptionManager, Monitor, geocode) {
  /**
   * Geocode Model Class.
   * @class
   * @name GeocodeModel
   * @param {Object} [options] Geocode options.
   */
  var GeocodeModel = defineClass(function (options) {
    this.events = new EventManager({ context: this });
    this.options = new OptionManager(options);
    this.data = new DataManager();
    this._setupMonitors();
  }, {
    /**
     * Geocodes model data.
     * @function
     * @name GeocodeModel.geocode
     * @param {Object} options Geocoder options implied to all requests.
     * @returns {vow.Promise} Promise resolved with geocoding results.
     */
    geocode: function (options) {
      this._fireEvent('requestsend');

      var promise;

      this.data.get('request').each(function (it) {
        promise = geocode(it, extend({}, this.options.getAll(), options));
      }, this);

      if(promise) {
        return promise.then(this._onRequestSuccess, this._onRequestFail, this);
      }
    },
    /**
     * Destroys model.
     * @function
     */
    destroy: function () {
      this.data.unsetAll();
      this._clearMonitors();

      return this;
    },
    _setupMonitors: function () {
      this._dataMonitor = new Monitor(this.data);
      this._dataMonitor.add('request', this._onRequestChange, this, {
        compareCallbacks: {
          request: function (newValue, oldValue) {
            if(newValue && newValue.valueOf()) {
              if(oldValue && oldValue.valueOf()) {
                return newValue.valueOf() !== oldValue.valueOf();
              }
              return true;
            }
            return false;
          }
        }
      });
      this._optionMonitor = new Monitor(this.options);
      this._optionMonitor.add(['boundedBy', 'strictBounds'], this._onRequestChange, this);
    },
    _clearMonitors: function () {
      this._optionMonitor.removeAll();
    },
    _onRequestChange: function () {
      this._fireEvent('requestchange');
      this.geocode();
    },
    _onRequestSuccess: function (response) {
      this.data.set({ response: response.data });
      this._fireEvent('requestsuccess');

      return response.data;
    },
    _onRequestFail: function (err) {
      this.data.set({ error: err });
      this._fireEvent('requestfail');

      throw err;
    },
    _fireEvent: function (name) {
      this.events.fire(name, {
        target: this
      });
    }
  });

  provide(GeocodeModel);
});

ym.modules.define('stat-model', [
  'util.defineClass',
  'util.extend',
  'event.Manager',
  'data.Manager',
  'component.xhr',
  'app-config'
], function (provide, defineClass, extend, EventManager, DataManager, XHR, config) {
  /**
   * Stat Model Class.
   * @class
   * @name StatModel
   */
  var StatModel = defineClass(function (options) {
    this.events = new EventManager({ context: this });
    this.data = new DataManager();
  }, {
    load: function () {
      this._fireEvent('requestsend');
      return new XHR(config.stat.url)
        .then(
          this._onRequestSuccess,
          this._onRequestFail,
          this
        );
    },
    _onRequestSuccess: function (response) {
      this.data.set(response.data);
      this._fireEvent('requestsuccess');

      return response;
    },
    _onRequestFail: function (err) {
      this.data.set({ error: err });
      this._fireEvent('requestfail');

      throw err;
    },
    _fireEvent: function (name) {
      this.events.fire(name, {
        target: this
      });
    }
  });

  provide(StatModel);
});

ym.modules.define('error-dom-view', [
  'util.defineClass'
], function (provide, defineClass) {
  var ErrorDomView = defineClass(function () {
    this._alert = jQuery([
      '<div class="popup alert alert-error">',
        '<button type="button" class="close" data-dismiss="alert">×</button>',
        '<h4>Произошла ошибка</h4>',
        '<p id="message"></p>',
      '</div>'
    ].join(''));
  }, {
    render: function (error) {
      jQuery('body').append(this._alert);
      this._alert.find('#message').text(
        error instanceof Error? error.message : error
      );
    },
    clear: function () {
      this._alert.remove();
    }
  });

  provide(ErrorDomView);
});

ym.modules.define('preloader-dom-view', [
  'util.defineClass'
], function (provide, defineClass) {
  var PreloaderDomView = defineClass(function () {
    this._preloader = jQuery([
      '<div class="preloader alert alert-info">',
        '<p>Пожалуйста, подождите, идет поиск...</p>',
        '<div class="progress progress-striped active">',
          '<div class="bar" style="width: 100%;"></div>',
        '</div>',
      '</div>'
    ].join(''));
  }, {
    render: function () {
      jQuery('body').append(this._preloader);
    },
    clear: function () {
      this._preloader.remove();
    }
  });

  provide(PreloaderDomView);
});

ym.modules.define('stat-dom-view', [
  'util.defineClass'
], function (provide, defineClass) {
  var StatDomView = defineClass(function () {
    this._stat = jQuery('#stat');
  }, {
    render: function (data) {
      var stat = this._stat;

      stat
        .find('#hit').text(data.hit);
      stat
        .find('#miss').text(data.miss);
    },
    clear: function () {
      var stat = this._stat;

      stat
        .find('#hit').text('0');
      stat
        .find('#miss').text('0');
    }
  });

  provide(StatDomView);
});

ym.modules.define('objects-map-view', [
  'util.defineClass',
  'Map',
  'ObjectManager',
  'templateLayoutFactory',
  'event.Manager'
], function (provide, defineClass, Map, ObjectManager, templateLayoutFactory, EventManager) {

  var MapView = defineClass(function (config) {
    this.events = new EventManager();
    this._map = new Map(config.container, config.state, config.options);
    this._objects = this._createObjectManager();
    this._map.geoObjects.add(this._objects);
  }, {
    render: function (data) {
      this._objects.add(data);
      this.focusOnObjects();

      return this;
    },
    clear: function () {
      this._objects.removeAll();

      return this;
    },
    _createObjectManager: function () {
      return new ObjectManager({
        geoObjectBalloonContentLayout: templateLayoutFactory.createClass([
          '<h3>{{ properties.name }}</h3>',
          '<p>{{ properties.description }}</p>'
        ].join(''))
      });
    },
    focusOnObjects: function () {
      this._map.setBounds(this._objects.getBounds(), {
        checkZoomRange: true,
        zoomMargin: 20
      });

    return this;
    },
    _setupListeners: function () {
    },
    _clearListeners: function () {
    },
  });

  provide(MapView);
});

ym.modules.define('component.error', [
], function (provide) {
  provide(function (detail) {
    var err = new Error(detail.message);
    err.code = detail.code;

    return err;
  });
});

ym.modules.define('component.querystring', [
], function (provide) {
  provide({
    parse: function (s) {
      var params = {};

      try {
        if(s.indexOf('?') > -1) {
          s = s.split('?')[1];
        }

        s.replace(/[^?&]+(?=&|$)/g, function (s) {
          var param = s.split('=');

          params[decodeURI(param[0])] = decodeURIComponent(param[1]);
        });
      }
      catch (e) {}

      return params;
    },
    stringify: function (data) {
      var params = [];

      try {
        for(var param in data) {
          params.push(encodeURI(param) + '=' + encodeURIComponent(data[param]));
        }
      }
      catch (e) {}

      return params.join('&');
    }
  });
});

ym.modules.define('component.xhr', [
  'vow',
  'component.querystring',
  'component.error'
], function (provide, vow, querystring, Error) {
  var XMLHttpRequest = window.XDomainRequest || window.XMLHttpRequest;
  var parseHeaders = function (headers) {
    return headers.split('\u000d\u000a').reduce(function (result, line) {
      var parts = line.split('\u003a\u0020');
      if(parts.length == 2) {
        result[parts[0].toLowerCase()] = parts[1].trim();
      }
      return result;
    }, {});
  };

  function XHR(url, options) {
    options = options || {};
    var defer = vow.defer();
    var xhr = new XMLHttpRequest();
    var data = options.data || null;
    var headers = options.headers || {};
    var method = (options.method || 'GET').toUpperCase();
    var timeout = options.timeout || 30000;

    function cleanUp() {
      xhr.onload = xhr.onerror = null;
    }

    if(!headers['X-Requested-With']) {
      headers['X-Requested-With'] = 'XMLHttpRequest';
    }

    if(data) {
      if(method === 'GET') {
        url += '?' + querystring.stringify(data);
      }
      /**
       * All objects will be sended as JSON string by default.
       * To send ArrayBufferView, Blob, Document and FormData use proper Content-Type header.
       */
      else if(typeof data === 'object' && !headers['Content-Type']) {
        data = JSON.stringify(data);
        headers['Content-Type'] = 'application/json';
      }
    }

    xhr.onload = function () {
      if(this.status >= 400) {
        return xhr.onerror();
      }

      var headers = this.getAllResponseHeaders();
      var cType = this.getResponseHeader('Content-Type') || 'text/plain';
      var response = cType.indexOf('xml') > -1 && this.responseXML || this.response || this.responseText;

      if(cType.indexOf('json') > -1 && typeof response === 'string') {
        try {
          response = JSON.parse(response);
        }
        catch(e) {
          return defer.reject(new Error({
            code: 500,
            message: 'JSON Parse Error ' + e.message
          }));
        }
      }

      cleanUp();
      defer.resolve({
        code: this.status,
        data: response,
        headers: !!options.parseResponseHeaders?
          parseHeaders(headers) : headers
      });
    };

    xhr.onerror = function () {
      defer.reject(new Error({
        code: this.status || 500,
        message: this.statusText || 'Internal Server Error'
      }));
    };

    xhr.open(method, url, true);

    Object.keys(headers).forEach(function (key) {
      xhr.setRequestHeader(key, headers[key]);
    });

    xhr.send(data);

    return defer.promise()
      .timeout(timeout)
      .fail(function (e) {
        cleanUp();
        if(e instanceof vow.TimedOutError) {
          xhr.abort();
          throw new Error({
            code: 408,
            message: 'Request Timeout'
          });
        }
        throw e;
      });
  }

  provide(XHR);
});

ym.modules.define('form-dom-view', [
  'util.defineClass',
  'event.Manager',
  'csv-form-state',
  'geojson-form-state'
], function (provide, defineClass, EventManager, CSVFormState, GeoJSONFormState) {

  var FormDomView = defineClass(function (config) {
    this.events = new EventManager();
    this._form = jQuery('form');
    this._setupListeners();
    this._setState(CSVFormState);
  }, {
    render: function (data) {
      jQuery('#response').val(JSON.stringify(data));

      return this;
    },
    clear: function () {
      jQuery('#response').val('');

      return this;
    },
    getRequestData: function () {
      return this._state.getRequestDataView();
    },
    _setState: function (State) {
      if(this._state) {
        this._state.destroy();
      }
      this._state = new State(this._form);
      this._state.init();
    },
    _setupListeners: function () {
      this._form
        .on('change', 'select#dataType', jQuery.proxy(this._onDataTypeChange, this))
        .on('submit', jQuery.proxy(this._onFormSubmit, this))
        .on('reset', jQuery.proxy(this._onFormReset, this));
    },
    _clearListeners: function () {
      this._form.off();
    },
    _onDataTypeChange: function (e) {
      e.preventDefault();

      var dataType = jQuery(e.target).val();

      switch(dataType) {
        case 'CSV':
          this._setState(CSVFormState);
          break;
        case 'GeoJSON':
          this._setState(GeoJSONFormState);
          break;
        default:
          throw new TypeError('Data Type ' + dataType + ' not supported');
      }
    },
    _onFormSubmit: function (e) {
      e.preventDefault();

      this.events.fire('formsubmit', { target: this });
    },
    _onFormReset: function (e) {
      this.events.fire('formreset', { target: this });
    }
  });

  provide(FormDomView);
});

ym.modules.define('csv-request-data-view', [
  'util.defineClass'
], function (provide, defineClass) {
  var CSVRequestDataView = defineClass(function (params) {
    this._data = (params.request || '').trim();
    this._delim = params.delim || '~';
  }, {
    each: function (fn, ctx) {
      this._data.split(this._delim)
        .filter(function (it) {
          return it.length > 0;
        }).forEach(fn, ctx);
    },
    valueOf: function () {
      return this._data;
    }
  });

  provide(CSVRequestDataView);
});

ym.modules.define('geojson-request-data-view', [
  'util.defineClass'
], function (provide, defineClass) {
  var GeoJSONRequestDataView = defineClass(function (params) {
    this._data = (params.request || '').trim();
  }, {
    each: function (fn, ctx) {
      try {
        var data = JSON.parse(this._data);
      }
      catch(e) {
        return;
      }

      (data.features || data).forEach(function (feature) {
        fn.call(ctx, feature.geometry.coordinates.join());
      });
    },
    valueOf: function () {
      return this._data;
    }
  });

  provide(GeoJSONRequestDataView);
});

ym.modules.define('csv-form-state', [
  'util.defineClass',
  'csv-request-data-view',
  'app-config'
], function (provide, defineClass, CSVRequestDataView, config) {
  var CSVFormState = defineClass(function (form) {
    this._form = form;
  }, {
    init: function () {
      var form = this._form;

      form.find('#delim')
        .show()
        .attr('placeholder', config.form.CSV.delim.placeholder)
        .removeAttr('disabled');

      form.find('label[for=request]').text(config.form.CSV.request.label);
      form.find('#request').attr('placeholder', config.form.CSV.request.placeholder);
    },
    destroy: function () {
      var form = this._form;

      form.find('#delim')
        .removeAttr('placeholder')
        .hide()
        .attr('disabled','disabled');
    },
    getRequestDataView: function () {
      var form = this._form;

      return new CSVRequestDataView({
        request: form.find('#request').val(),
        delim: form.find('#delim').val()
      });
    }
  });

  provide(CSVFormState);
});

ym.modules.define('geojson-form-state', [
  'util.defineClass',
  'geojson-request-data-view',
  'app-config'
], function (provide, defineClass, GeoJSONRequestDataView, config) {
  var GeoJSONFormState = defineClass(function (form) {
    this._form = form;
  }, {
    init: function () {
      var form = this._form;

      form.find('label[for=request]').text(config.form.GeoJSON.request.label);
      form.find('#request').attr('placeholder', config.form.GeoJSON.request.placeholder);
    },
    destroy: function () {
      var form = this._form;

      form.find('#delim')
        .hide()
        .removeAttr('placeholder')
        .attr('disabled','disabled');
    },
    getRequestDataView: function () {
      return new GeoJSONRequestDataView({
        request: this._form.find('#request').val()
      });
    }
  });

  provide(GeoJSONFormState);
});

})(this);